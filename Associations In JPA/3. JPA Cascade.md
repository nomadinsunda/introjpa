# 🌱 1. 왜 JPA에서 Cascade가 중요한가?

JPA를 처음 배울 때는 보통 이렇게 생각하십니다.

> “엔티티를 저장하려면 `em.persist()` 하면 되지 않나?”

그런데 실무로 가면 대부분의 도메인은 **객체 그래프(Object Graph)** 입니다.

```text
Order ──┬─ OrderItem 1
        ├─ OrderItem 2
        └─ Delivery
```

* `Order`만 저장하고 싶어도, 사실 **OrderItem, Delivery까지 함께 관리**해야 합니다.
* SQL에서는 `INSERT`를 여러 번 수행해야 하고,
* JPA는 엔티티 단위로 동작하기 때문에 **“루트 엔티티만 다루고 싶다”** 는 요구가 강합니다.

여기서 등장하는 개념이 바로 **Cascade(영속성 전이)** 입니다. 🎯

> “부모(Parent) 엔티티에 대한 작업을 할 때,
> **연관된 자식(Child) 엔티티에도 같은 생명주기 작업을 전파**해 주는 기능”

---

# 🔁 2. JPA 엔티티 생명주기(Lifecycle) 먼저 짚고 가기

Cascade를 이해하려면 먼저 **엔티티의 상태(state)** 를 알아야 합니다.

JPA에서 엔티티는 크게 4가지 상태를 가집니다.

## 2.1 엔티티 4가지 상태 🌈

1. **Transient (비영속)**

   * 아직 `EntityManager`가 모르는 새 객체
   * DB와 전혀 연관 없음

   ```java
   Order order = new Order(); // 아직 비영속
   ```

2. **Persistent (영속)**

   * `em.persist(order)` 이후
   * **영속성 컨텍스트에서 관리 중**
   * flush 시점에 INSERT/UPDATE 수행

3. **Detached (준영속)**

   * 한 번 영속이었지만, 더 이상 `EntityManager`가 관리하지 않는 상태
   * ex) `em.clear()`, `em.detach(order)`, 트랜잭션 종료 등

4. **Removed (삭제 예정)**

   * `em.remove(order)` 호출
   * flush 시점에 DELETE 수행

---

💡 **Cascade란?**
위 4가지 상태 전이를 시킬 때,
**“부모에 수행한 상태 전이 작업을 자식에게도 전달해라”** 라는 설정입니다.

---

# 👪 3. Parent / Child, Aggregate Root 관점에서의 Cascade

JPA에서 Cascade는 **“엔티티 그래프의 중심(루트)을 하나 두고, 거기서 나머지를 같이 관리하자”** 는 철학을 갖고 있습니다.

* **Parent(부모)**: 생명주기의 기준이 되는 엔티티 (보통 Aggregate Root)
* **Child(자식)**: 부모에 종속된 엔티티

예제 도메인:

```java
@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
    private List<OrderItem> orderItems = new ArrayList<>();

    // 연관관계 편의 메서드
    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
        item.setOrder(this);
    }
}

@Entity
public class OrderItem {
    @Id @GeneratedValue
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Order order;
}
```

여기서:

* **Order = Parent**
* **OrderItem = Child**
* `cascade = CascadeType.ALL`
  → Order의 생명주기 변화가 OrderItem에도 그대로 **전파**됩니다.

---

# 🔍 4. CascadeType 종류별 동작 정리

JPA 표준에서 제공하는 Cascade 종류는 다음과 같습니다.

```java
public enum CascadeType {
    ALL,
    PERSIST,
    MERGE,
    REMOVE,
    REFRESH,
    DETACH
}
```

각각이 **어떤 EntityManager 메서드와 연결되는지**가 핵심입니다. ⚙️

---

## 4.1 CascadeType.PERSIST 🧩 – 저장 전파

> 부모를 `persist()` 할 때, 자식도 함께 영속 상태로 만든다.

```java
Order order = new Order();
OrderItem item1 = new OrderItem();
OrderItem item2 = new OrderItem();

order.addOrderItem(item1);
order.addOrderItem(item2);

em.persist(order); // 👈 orderItems에도 PERSIST 전파
```

* `cascade = PERSIST`가 설정된 연관관계라면,

  * `em.persist(order)` 한 번으로
    `order`, `item1`, `item2` 모두 **영속 상태**가 됩니다.
* SQL 관점:

  * flush 시점에 `INSERT ORDER`, `INSERT ORDER_ITEM ...` 각각 수행

### 사용 시점

* Parent가 Child를 **소유/관리하는 구조**일 때
* Child를 따로 `persist()` 하고 싶지 않을 때
* DDD Aggregate Root 패턴에서 Root만 저장하도록 할 때

---

## 4.2 CascadeType.MERGE 🔄 – 변경 내용 병합 전파

> 부모를 `merge()` 할 때, 자식의 변경도 함께 병합

`merge()`는 **준영속(detached) 상태 엔티티를 다시 영속으로 만들 때** 사용합니다.

```java
Order detachedOrder = ... // 준영속 상태 (ex. 컨트롤러에서 넘어온 DTO를 엔티티로 매핑)
Order mergedOrder = em.merge(detachedOrder); // 👈 Cascade.MERGE가 있으면 child도 merge
```

* Parent에 대한 merge 수행 시,
* CascadeType.MERGE가 걸려 있는 Child들도 **함께 merge 대상**

실무에서는 보통:

* 영속 상태 엔티티를 트랜잭션 안에서 바로 수정하는 패턴을 추천하고
* `merge()`는 선호하지 않는 편입니다. (복잡도, 예측 어려움)

그래도 CascadeType.ALL에 포함되어 있으므로,
**개념적으로는 알고 있어야** 합니다.

---

## 4.3 CascadeType.REMOVE ❌ – 삭제 전파

> 부모를 `remove()` 할 때, 자식도 함께 삭제

```java
Order order = em.find(Order.class, orderId);
em.remove(order); // 👈 orderItems도 모두 삭제 (cascade = REMOVE)
```

* Parent 삭제 시, 연관된 Child들도 자동으로 `remove()` 전파
* SQL:

  * 보통 Child DELETE → Parent DELETE 순으로 수행
    (FK 제약 조건 때문에)

### 주의할 점 ⚠️

* **ManyToOne 쪽에 CascadeType.REMOVE를 걸면 안 되는 경우가 대부분**입니다.

  * 예: `OrderItem` → `Item`에 `cascade = ALL` 걸면,
  * OrderItem 삭제할 때 Item까지 같이 삭제될 위험 💣
* REMOVE는 **합성(Composition) 관계**일 때만 사용하는 것이 정석에 가깝습니다.

  * ex) Order–OrderItem, Board–AttachedFile 등

---

## 4.4 CascadeType.REFRESH 🔁 – DB 상태로 재동기화 전파

> 부모를 `em.refresh(parent)` 할 때, 자식도 DB 상태로 다시 읽어옴

* 잘 사용되지는 않지만,
* 캐시된 엔티티 상태를 **완전히 DB 기준으로 리셋**하고 싶을 때 사용
* Child에 대해서도 같은 동작을 하도록 전파

실무에서는 주로 **운영/관리성 코드**에서 간헐적으로 등장하는 정도입니다.

---

## 4.5 CascadeType.DETACH 🔌 – 영속성 컨텍스트 분리 전파

> 부모를 `em.detach(parent)` 할 때, 자식들도 모두 준영속(detached)로 전환

* 특정 그래프를 영속성 컨텍스트에서 통째로 떼어내고 싶을 때
* Child들도 함께 더 이상 관리하지 않게 됨

이 역시 실무에서 자주 쓰이진 않습니다.
하지만 CascadeType.ALL에 포함되므로 개념은 알고 있어야 합니다.

---

## 4.6 CascadeType.ALL 🌐 – 위 모든 것을 한 번에

```java
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
```

* `PERSIST, MERGE, REMOVE, REFRESH, DETACH` 모두 전파
* “Parent에 하는 모든 생명주기 작업을 Child에도 동일하게 적용해라”

**그렇다고 해서 무조건 ALL을 쓰면 되는 것은 아닙니다.**
→ 아래에서 Best Practice/Anti-Pattern에서 다시 짚겠습니다.

---

# 🧹 5. orphanRemoval과 Cascade REMOVE의 차이

많이 헷갈리는 부분이 바로 이 두 가지입니다.

```java
@OneToMany(mappedBy = "order",
           cascade = CascadeType.ALL,
           orphanRemoval = true)
private List<OrderItem> orderItems;
```

## 5.1 CascadeType.REMOVE

> Parent 엔티티를 `remove()`할 때,
> 연관된 Child도 함께 삭제

* 트리 루트가 제거될 때 서브트리까지 같이 제거하는 느낌

## 5.2 orphanRemoval = true

> Parent–Child 관계가 끊어진 **“고아 엔티티”** 를 자동 삭제

```java
Order order = em.find(Order.class, orderId);
order.getOrderItems().remove(0); // 컬렉션에서 제거

// flush 시점에 제거된 OrderItem에 대해 DELETE SQL 발생
```

* Parent는 그대로 살아 있는데,
* 특정 Child만 관계에서 제거되면 → 그 Child는 “부모 잃은 고아(orphan)”
* `orphanRemoval = true`라면 그 고아 Child는 DB에서도 자동 삭제

### 요약 비교 💡

| 기능                     | 트리거                 | 삭제 대상             |
| ---------------------- | ------------------- | ----------------- |
| `cascade = REMOVE`     | `em.remove(parent)` | Parent + Child 전체 |
| `orphanRemoval = true` | 부모 컬렉션/연관에서 자식을 제거  | 제거된 Child만        |

합성(Composition) 모델에서 매우 유용한 패턴입니다.

---

# ✅ 6. Cascade 사용 시 실무 Best Practice

## 6.1 “Aggregate Root에만 Cascade를 사용하라” 🏠

DDD 관점에서:

* **Aggregate Root**: 외부에서 접근 가능한 유일한 진입점
* Aggregate 내부 엔티티: Root에 의해 관리, 외부에서 직접 조작 ❌

따라서:

* Root ↔ 내부 엔티티 관계 = **Composition 느낌**
* 이때:

  * `cascade = CascadeType.ALL`
  * `orphanRemoval = true`
* 를 사용하면 **아주 자연스럽게 Aggregate Lifecycle을 구현**할 수 있습니다.

예시:

```java
class Order { // Aggregate Root
    @OneToMany(mappedBy = "order",
               cascade = CascadeType.ALL,
               orphanRemoval = true)
    private List<OrderItem> orderItems;
}
```

이제 비즈니스 로직에서는:

```java
Order order = new Order();
order.addOrderItem(new OrderItem(...));
order.addOrderItem(new OrderItem(...));

em.persist(order); // ✅ Order만 persist하면 됨
```

## 6.2 ManyToOne에는 웬만하면 Cascade를 쓰지 마라 ⚠️

```java
@ManyToOne(cascade = CascadeType.ALL)
private Item item;  // ❌ 매우 위험
```

이렇게 하면:

* OrderItem 삭제 시 Item도 같이 삭제
* 다른 주문에서 사용하는 Item까지 날려버리는 참사 가능 😱

### 원칙:

* **ManyToOne(다대일) 관계에는 보통 cascade를 사용하지 않습니다.**
* ManyToOne으로 참조하는 쪽은 대개 “공유 Aggregation”이기 때문입니다.

## 6.3 “연관관계 주인(Owner)”과 Cascade는 역할이 다르다

* **Owner**: FK를 실제로 변경하는 주체
  (`mappedBy`가 없는 쪽)
* **Cascade**: 생명주기 전파 설정

둘을 혼동하면 안 됩니다.

---

# 🔥 7. Anti-Pattern: 이렇게 쓰면 망합니다

1. **엔티티 거의 전부에 CascadeType.ALL 남용**

   * 시스템 전체가 **거대한 한 묶음**처럼 움직여버림
   * 한 엔티티 삭제 시 예상치 못한 연쇄 삭제

2. **ManyToOne에 CascadeType.REMOVE 설정**

   * Child 삭제 시, 공유 Parent까지 삭제

3. **Aggregation 관계에 Composition 수준의 Cascade 설정**

   * 원래 독립적이어야 할 엔티티가, 잘못된 라이프사이클 종속을 갖게 됨

4. **orphanRemoval를 비즈니스 의도와 상관없이 아무 데나 켜기**

   * 단순히 관계만 끊고 싶었는데, 실제로는 DB에서 DELETE

---

# 📌 8. 정리: Cascade 생명주기 모델 한눈에 요약

1. **Cascade의 본질**
   → 부모(Parent)에 수행한 생명주기 작업을 자식(Child)으로 전파하는 모델

2. **엔티티 상태 4단계**
   → Transient, Persistent, Detached, Removed
   → `persist/merge/remove/detach/refresh`에 반응해서 상태 전이

3. **CascadeType**

   * `PERSIST`: 저장 전파
   * `MERGE`: 병합 전파
   * `REMOVE`: 삭제 전파
   * `REFRESH`: DB 상태로 리셋 전파
   * `DETACH`: 준영속 전환 전파
   * `ALL`: 위 전부

4. **orphanRemoval**
   → 연관관계에서 제거된 고아 엔티티 자동 삭제

5. **좋은 사용 패턴**

   * Aggregate Root → 내부 엔티티: `cascade = ALL + orphanRemoval = true`
   * ManyToOne에는 대부분 cascade 사용 ❌
   * Parent/Child를 명확히 구분하고, 생명주기 책임을 Root가 갖게 설계

