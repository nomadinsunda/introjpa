# 🧩 왜 `User`가 아니라 `Profile`이 외래 키(FK)를 가져야 할까?

### ― 실무 엔티티 설계에서 자주 등장하는 1:1 매핑의 진실

많은 개발자분들이 처음 JPA나 데이터베이스 설계를 하실 때 가장 먼저 떠올리는 구조는 다음과 같습니다.

> “사용자(User)가 프로필(Profile)을 가진다 → 그럼 User 테이블이 Profile의 FK를 가지겠네?”

겉보기에는 자연스러워 보이지만, **실무에서는 정반대 방향**으로 설계를 합니다.
즉, **Profile 테이블이 `user_id`를 FK로 가지도록** 설계하죠.

왜 이렇게 할까요? 🤔
이번 글에서는 그 이유를 객체지향, DB 설계, 성능·확장성 측면에서 깊이 있게 분석해보겠습니다.

---

# 1️⃣ 객체지향적 관점: “누가 누구에게 종속되는가?”

### ✔ `User`는 시스템의 핵심 엔티티

* 프로필이 없어도 로그인 가능
* 권한 관리, 인증, 활동 기록 등 전 서비스의 중심
* 즉, **독립적인 존재**

### ✔ `Profile`은 사용자(User)에 의존

* 프로필만 존재해도 아무 의미 없음
* 반드시 User가 있어야 생성 가능
* 즉, **종속적인 존재**

이 관계는 아래처럼 자연스럽게 정리됩니다.

```
User 1 ────< Profile 1
(주 테이블)    (대상 테이블)
```

👉 **주 테이블(User)이 대상 테이블(Profile)을 참조하는 것이 아니라,
대상 테이블(Profile)이 주 테이블(User)을 참조하는 것이 자연스럽습니다.**

### 💡 User가 profile_id를 가지면 발생하는 문제

* User를 생성할 때 profile_id 값을 어떻게 처리할 것인가?

  * 생성 시점에는 프로필이 없음 → null 허용해야 함
* 새로운 상세정보 테이블이 늘어날수록 User가 점점 비대해짐

즉, **객체 모델과 생성 책임이 어색해지고, 확장성도 떨어집니다.**

---

# 2️⃣ 데이터베이스 관점: “핵심 테이블은 가볍게 유지하라!” 🏋️‍♂️

서비스에서 가장 빈번하게 조회되는 테이블이 무엇일까요?
바로 **User 테이블**입니다.

* 로그인 검증
* 권한 체크
* 세션·토큰 연동
* 각종 서비스 요청의 소유자 확인

이 핵심 테이블이 비대해지면 **조회 비용이 증가**하고,
컬럼이 늘어나면서 **테이블 관리 비용도 증가**합니다.

### ✔ User가 단일 테이블로 계속 확장되면?

User
├── profile_id
├── settings_id
├── account_id
├── privacy_id
├── … (끝없는 확장)

😨 “User 테이블이 쓰레기장이 되어버린다!”

### ✔ 반대로 Profile이 FK를 가지면?

User는 최소 정보만 유지 → **가볍고 안정적 유지**
프로필, 환경설정, 부가 정보는 개별 테이블로 모듈화 가능 → **확장성 최고**

**즉, FK를 Profile이 가지는 방식이 서비스 유지보수성·성능 면에서 훨씬 유리합니다.**

---

# 3️⃣ 반대 방향 설계(User가 FK 소유)도 가능하다면?

물론 가능합니다. 그러나 실무에서는 거의 사용하지 않습니다.
아래는 User가 FK를 가지는 방식의 예시입니다.

```java
@Entity
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profile_id")
    private Profile profile;
}

@Entity
public class Profile {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String bio;
}
```

### ❌ 문제점

프로필(Profile)을 조회할 때 **누구의 프로필인지 알 수 없음**
→ 반드시 User 테이블과 JOIN해야 함
→ 단일 테이블 조회 불가능
→ Repository 레벨에서 비효율 발생

---

# 4️⃣ 핵심 요약 🚀

| 비교 기준        | Profile이 `user_id` FK 소유 (권장) | User가 `profile_id` FK 소유       |
| ------------ | ----------------------------- | ------------------------------ |
| User 테이블의 무게 | ⭐ 가벼움                         | ❌ 점점 비대해짐                      |
| 생성 시점 자연스러움  | ⭐ User 생성 후 Profile 생성 가능     | ❌ User 생성 시 Profile null 처리 필요 |
| 조회 효율성       | ⭐ Profile 조회만으로 소유자 파악        | ❌ 반드시 User와 JOIN해야 함           |
| 향후 확장성       | ⭐ 모듈화, 독립적 확장 용이              | ❌ User 필드 난립                   |
| 객체지향적 의미     | ⭐ “부가 정보가 핵심을 참조한다”           | ❌ 자연스럽지 않음                     |

---

# 🏁 결론

**User는 시스템의 중심이며 가능한 한 깨끗하고 단순해야 합니다.**
반면에 Profile은 종속적이고 부가적인 엔티티입니다.

따라서 실무적인 1:1 매핑에서는
👉 **Profile(대상 엔티티)이 User의 FK를 소유하는 방식이 가장 자연스럽고 확장성이 좋습니다.**


