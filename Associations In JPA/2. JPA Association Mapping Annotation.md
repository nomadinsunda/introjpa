
# 📘 JPA 연관 매핑 어노테이션

> 대상 어노테이션:
> `@Entity`, `@Id`, `@GeneratedValue`,
> `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`,
> `@JoinColumn`, `@JoinTable`,
> 그리고 이들과 함께 자주 쓰이는 `mappedBy`, `cascade`, `fetch` 속성입니다.

---

## 1. 🧱 엔티티 기본 어노테이션

### 1-1. `@Entity` — “이 클래스는 테이블이며 각 인스턴스는 테이블의 row입니다”

```java
@Entity
public class Order {
    // ...
}
```

**역할**

* 해당 클래스를 **JPA가 관리하는 엔티티** 로 선언합니다.
* 즉, 이 클래스는 데이터베이스의 **테이블과 1:1 매핑되는 도메인 모델** 이 됩니다.

**주요 특징**

* 기본적으로 클래스명(예: `Order`)이 테이블명으로 사용됩니다.

  * 필요하면 `@Table(name = "orders")` 같이 변경할 수 있습니다.
* `@Entity`가 붙은 클래스는 **기본 생성자(파라미터 없는 생성자)** 를 반드시 가져야 합니다.
* `final`, `enum`, `interface`, `inner class`에는 사용할 수 없습니다.

**실무 팁 💡**

* 엔티티 클래스 이름은 되도록 **비즈니스 용어 그대로** 사용하시는 것이 유지보수에 좋습니다.
  예: `OrderEntity` 보다는 `Order`, `UserEntity` 보다는 `User`.

---

### 1-2. `@Id` — “이 필드는 PK입니다”

```java
@Entity
public class Order {

    @Id
    private Long id;
}
```

**역할**

* 엔티티의 **기본 키(Primary Key)** 필드를 지정합니다.
* JPA는 이 필드를 기준으로 엔티티를 식별하고 1차 캐시에 보관합니다.

**주의할 점**

* 반드시 하나 이상 선언해야 합니다.
* 복합 키가 필요한 경우 `@IdClass` 또는 `@EmbeddedId`를 사용합니다.

---

### 1-3. `@GeneratedValue` — “PK 값을 어떻게 생성할 것인가”

```java
@Id
@GeneratedValue
private Long id;
```

**역할**

* 기본 키의 값을 **자동으로 생성**하도록 지정합니다.

**주요 전략**

```java
@GeneratedValue(strategy = GenerationType.AUTO)    // 기본값, 벤더에 따라 동작
@GeneratedValue(strategy = GenerationType.IDENTITY) // DB identity 사용 (MySQL 등)
@GeneratedValue(strategy = GenerationType.SEQUENCE) // 시퀀스 객체 사용 (Oracle, PostgreSQL)
@GeneratedValue(strategy = GenerationType.TABLE)    // 키 생성용 테이블 사용
```

**실무 팁 💡**

* MySQL/MariaDB를 쓰실 경우 `IDENTITY` 전략을 많이 사용합니다.
* 성능·이식성을 고려하면 **SEQUENCE + @SequenceGenerator** 조합이 가장 유연합니다.

---

## 2. 🔗 연관관계 매핑 어노테이션

이제 연관 매핑의 핵심인 관계 어노테이션들을 살펴보겠습니다.
앞서 설명하신 `Order ↔ OrderItem`, `User ↔ PhoneNumber`, `Student ↔ Course` 예시들 모두 여기에 해당합니다.

---

### 2-1. `@ManyToOne` — “N:1 관계의 주인”

```java
@Entity
public class OrderItem {

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id")
    private Order order;
}
```

**역할**

* **여러 개의 자식 엔티티(N)** 가 **하나의 부모 엔티티(1)** 를 참조할 때 사용합니다.
* 보통 **외래 키를 가진 쪽**, 즉 자식 엔티티에 선언되며,
  **항상 연관관계의 주인(owner)** 입니다.

**기본 속성**

* `fetch`: 기본값은 `EAGER` 이지만, 실무에서는 반드시 `LAZY`를 명시하는 것이 좋습니다.
* `optional`: 기본값 `true` → `false`로 설정하면 NOT NULL 제약을 의미합니다.

**실무 팁 💡**

* 실무에서 가장 자주 쓰는 어노테이션입니다.
* `@ManyToOne(fetch = FetchType.LAZY)`는 거의 “템플릿”처럼 암기하셔도 좋습니다.

---

### 2-2. `@OneToMany` — “1:N, 그러나 주인은 아닙니다”

```java
@Entity
public class Order {

    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();
}
```

**역할**

* **하나의 엔티티(1)** 가 **여러 엔티티(N)** 를 가진 관계를 표현합니다.
* 보통 부모(1) 쪽에 선언됩니다.

**중요 속성**

* `mappedBy = "order"`

  * **연관관계의 비주인(inverse side)** 임을 의미합니다.
  * `"order"`는 반대편 엔티티(`OrderItem`) 안에 있는 **필드명**입니다.
* `cascade`, `fetch` 등도 사용할 수 있습니다.

**왜 비주인인가?**

* 실제 **외래 키는 N쪽(자식)의 테이블**에 존재합니다.
* 따라서 N쪽 필드(`@ManyToOne`)이 관계의 주인이며,
  1쪽의 `@OneToMany`는 “읽기 전용 뷰”에 가깝습니다.

**실무 팁 💡**

* **단방향 `@OneToMany` + `@JoinColumn` 조합은 신중하게 사용**하셔야 합니다.
  (추가 UPDATE 발생 등 이슈)
* 양방향 매핑이 필요하다면,
  `@ManyToOne`(주인) + `@OneToMany(mappedBy = ...)`(비주인) 패턴이 정석입니다.

---

### 2-3. `@OneToOne` — “1:1 관계”

```java
@Entity
public class Citizen {

    @OneToOne
    @JoinColumn(name = "passport_id")
    private Passport passport;
}
```

**역할**

* 한 엔티티가 다른 엔티티와 **1:1로만 연결되는 관계**를 표현합니다.

**FK 위치에 따라 두 가지 방식**

1. **주 테이블에 FK**

   * `Citizen`에 `passport_id` FK 컬럼 존재
   * 조회 시 조인 빈도가 높다면 이 방식이 유리합니다.

2. **대상 테이블에 FK**

   * `Passport`에 `citizen_id` FK 컬럼 존재
   * 외래 키 관리를 어디에 둘지에 따라 설계합니다.

**실무 팁 💡**

* 1:1 관계는 잘못 설계하면 EAGER 로딩과 결합되어 성능 이슈가 생기기 쉽습니다.
* 정말 1:1이 맞는지, 사실상 1:N 관계는 아닌지 한 번 더 고민하시는 것이 좋습니다.

---

### 2-4. `@ManyToMany` — “N:M, 하지만 실무에서는 거의 안 씁니다”

```java
@Entity
public class Student {

    @ManyToMany
    @JoinTable(name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id"))
    private List<Course> courses = new ArrayList<>();
}
```

**역할**

* 다대다 관계를 단순하게 매핑하는 어노테이션입니다.
* 내부적으로는 **조인 테이블(bridge table)** 을 통해 N:1 + 1:N으로 풀어서 동작합니다.

**문제점**

* 조인 테이블에 **추가 컬럼(등록일, 상태, 점수 등)을 넣기 어렵습니다.**
* 조인 테이블이 코드 상에서 “숨겨져” 있어서 추적이 어렵습니다.
* 실무에서 요구사항이 복잡해질수록 관리가 힘듭니다.

**실무 패턴 💡**

* 대부분 아래와 같이 **중간 엔티티**를 도입합니다.

```text
Student ----< Enrollment >---- Course
```

```java
@Entity
public class Enrollment {
    @ManyToOne
    @JoinColumn(name = "student_id")
    private Student student;

    @ManyToOne
    @JoinColumn(name = "course_id")
    private Course course;

    private LocalDate enrolledAt;
    private String status;
}
```

> `@ManyToMany`는 “데모용/학습용”으로는 좋지만,
> **실제 서비스 코드에서는 중간 엔티티 패턴을 권장**드립니다. 🚨

---

## 3. 🔩 조인 관련 어노테이션

### 3-1. `@JoinColumn` — “FK 컬럼을 직접 지정합니다”

```java
@ManyToOne
@JoinColumn(name = "order_id")
private Order order;
```

**역할**

* 연관관계에서 사용할 **외래 키 컬럼 이름**을 지정합니다.
* 기본값을 사용하면 JPA가 `필드명 + _ + 참조 대상의 PK` 형태로 이름을 생성하려고 합니다.

  * 예: `order_id`, `user_id` 등

**주요 속성**

* `name` : FK 컬럼명
* `nullable` : `false`로 설정 시 NOT NULL 제약
* `unique` : 유니크 제약 (1:1 관계에서 유용)
* `insertable`, `updatable` : 읽기 전용 컬럼으로 만들 때 사용

**실무 팁 💡**

* 컬럼 이름을 명시적으로 관리하시려면 **DDL과 동일한 이름**으로 맞춰 주시는 것이 좋습니다.
* 설계 문서/ERD와 코드의 FK 명이 일치하면 유지보수가 훨씬 수월합니다.

---

### 3-2. `@JoinTable` — “조인 테이블 구조를 명시합니다”

```java
@ManyToMany
@JoinTable(name = "student_course",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id"))
private List<Course> courses;
```

**역할**

* **조인 테이블(bridge table)** 을 명시적으로 정의하는 어노테이션입니다.
* `@ManyToMany`와 함께 가장 많이 사용됩니다.

**주요 속성**

* `name` : 조인 테이블 이름
* `joinColumns`

  * 현재 엔티티를 참조하는 FK 컬럼 정의
  * 예: `student_id` (Student의 PK)
* `inverseJoinColumns`

  * 반대편 엔티티를 참조하는 FK 컬럼 정의
  * 예: `course_id` (Course의 PK)

**실무 팁 💡**

* `@ManyToMany`를 사용하지 않더라도,
  복잡한 조인 구조를 설계할 때 `@JoinTable`을 직접 활용하는 케이스도 있습니다.

---

## 4. ⚙️ 부가 속성: `mappedBy`, `cascade`, `fetch`

### 4-1. `mappedBy` — “나는 주인이 아닙니다”

```java
@OneToMany(mappedBy = "order")
private List<OrderItem> orderItems;
```

**역할**

* 양방향 연관관계에서 **비주인(inverse side)** 을 지정합니다.
* `mappedBy`에 들어가는 값은 **반대편 엔티티의 필드명**입니다.

  * 여기서는 `OrderItem` 클래스 안의 `order` 필드

**중요 포인트**

* `mappedBy`가 있는 쪽은 **절대 FK를 변경하지 않습니다.**
* FK 업데이트는 언제나 **주인(Owner)** 만 수행합니다.

---

### 4-2. `cascade` — “영속성 전이를 어떻게 할 것인가”

```java
@OneToMany(mappedBy = "order", cascade = CascadeType.ALL)
private List<OrderItem> orderItems;
```

**역할**

* 부모 엔티티에 대한 작업(persist, remove 등)을
  자식 엔티티에 **전파(cascade)** 할지 여부를 결정합니다.

**주요 옵션**

* `CascadeType.PERSIST` : 부모 저장 시 자식도 함께 저장
* `CascadeType.MERGE` : 병합 시 자식도 함께 병합
* `CascadeType.REMOVE` : 부모 삭제 시 자식도 함께 삭제
* `CascadeType.ALL` : 위 모든 동작을 전이

**실무 팁 💡**

* **생명주기를 완전히 함께하는 엔티티**에서만 `ALL`을 사용하시는 것이 좋습니다.
  예: `Order` – `OrderItem`
* 다른 서비스·모듈에서도 재사용되는 엔티티에 무분별하게 `ALL`을 설정하면
  의도치 않은 삭제/저장 전이가 발생할 수 있습니다. 🚨

---

### 4-3. `fetch` — “언제 연관 엔티티를 불러올 것인가”

```java
@ManyToOne(fetch = FetchType.LAZY)
private Order order;
```

**옵션**

* `FetchType.EAGER`

  * 엔티티를 조회할 때 **항상 즉시 연관 엔티티를 함께 조회**합니다.
  * 조인/서브쿼리 등이 자동으로 포함됩니다.
* `FetchType.LAZY`

  * 실제 해당 연관 엔티티가 필요할 때까지 **프록시로 지연 로딩**합니다.
  * 성능 튜닝의 기본이 되는 전략입니다.

**기본값**

* `@ManyToOne`, `@OneToOne` → `EAGER` (그래서 명시적으로 `LAZY`로 바꾸는 것이 권장됩니다.)
* `@OneToMany`, `@ManyToMany` → `LAZY`

**실무 팁 💡**

* 실무에서의 기본 가이드라인은 다음과 같습니다.

> “**모든 연관관계는 LAZY로 시작하고, 필요할 때만 Fetch Join으로 최적화한다.**”

---

## 5. 🎯 정리 및 마무리

위에서 다룬 어노테이션들은 JPA 연관 매핑의 **핵심 문법이자, 성능·설계 품질의 출발점**입니다.

* `@Entity`, `@Id`, `@GeneratedValue`
  → 엔티티의 정체성과 식별자를 정의하는 기초 블록
* `@OneToOne`, `@OneToMany`, `@ManyToOne`, `@ManyToMany`
  → DB 관계를 객체 간 관계로 옮기는 핵심 키워드
* `@JoinColumn`, `@JoinTable`
  → FK 및 조인 테이블을 명확히 제어하는 도구
* `mappedBy`, `cascade`, `fetch`
  → **누가 주인인지, 생명주기를 어떻게 묶을지, 언제 로딩할지**를 결정하는 중요한 속성

