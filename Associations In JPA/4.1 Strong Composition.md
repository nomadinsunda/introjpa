# 🟥 Strong Composition (강한 합성) — “부모와 자식의 생명주기를 하나의 객체처럼 묶는 관계”

Strong Composition(강합성)은 객체 모델링과 DDD에서 매우 중요한 개념입니다.
Weak Composition이나 Aggregation과는 비교도 안 될 정도로 **결합도(Coupling)와 생명주기(Lifecycle) 통일성이 가장 강한 관계**입니다.

분명하게 말하면:

> **Strong Composition은 “부모가 없으면 자식은 존재할 수 없다”를 기술적으로, 구조적으로, 생명주기적으로 강제하는 관계**이다.

이 관계는 JPA에서 다음 요소의 조합으로 구현됩니다:

* **CascadeType.ALL**
* **orphanRemoval = true**
* **연관관계의 주인은 반드시 Child**
* **Child는 절대 다른 Parent로 이동할 수 없음 (도메인 규칙)**

이 요소들이 함께 동작할 때
자식은 부모의 연장선처럼 존재합니다.

---

# 🟥 1. Strong Composition이 필요한 이유

도메인 모델에서 다음과 같은 요구사항이 있을 때 Strong Composition이 등장합니다.

### ✔ 자식은 부모 없이는 의미가 없다

예: OrderItem은 Order 없이 존재 불가능
예: DeliveryAddress는 Delivery 없이 존재 불가능

### ✔ 부모의 CRUD가 자식의 CRUD를 100% 결정해야 한다

부모가 저장되면 자식도 저장
부모가 삭제되면 자식도 삭제
부모가 detach되면 자식도 detach

### ✔ 자식이 독립적으로 저장/삭제되는 것을 허용해서는 안 된다

→ 도메인 일관성(Consistency)이 깨짐
→ 고아 데이터(Ghost Data) 발생 가능

---

## 💡 Strong Composition의 본질 요약

> “부모 – 자식 = 하나의 단일 Aggregate Root + 내부 엔티티 구조”

---

# 🟥 2. Strong Composition의 구조적 특징

Strong Composition은 다음 두 가지 관점이 모두 필요합니다:

## 1) **객체 모델(OOP) 차원**

* Parent만 new 할 수 있음
* Child는 Parent 메서드를 통해서만 관리됨
* Child는 Parent 외부에서 생성/삭제 불가
  (Setter 개방하면 안 됨)

## 2) **RDB 차원**

* FK는 반드시 자식(Child) 테이블에 존재
* FK는 NOT NULL 제약이어야 하며
  → Child는 parent_id 없이 생성될 수 없음
* Child는 다른 Parent로 이동하지 않는다
  → FK 변경 금지 또는 금지 메서드 설계

---

# 🟥 3. JPA @OneToMany / @OneToOne로 구현되는 Strong Composition

Strong Composition은 다음 조합으로 기술됩니다.

### 🧩 핵심 조합

```java
@OneToMany(mappedBy = "parent",
           cascade = CascadeType.ALL,
           orphanRemoval = true)
```

* **CascadeType.ALL** → 생명주기 전파
* **orphanRemoval = true** → 고아 데이터 자동 삭제
* **mappedBy** → FK 유지 주인은 Child

이 3개가 모두 있어야 **Strong Composition이 완성**됩니다.

---

# 🟥 4. Strong Composition의 생명주기 — 정확한 동작 흐름

여기서는 Hibernate ActionQueue 기준으로 설명합니다.

---

## ✔ 1. Parent.persist() → Child.persist() 자동 전파

```java
Order order = new Order();
order.addItem(new OrderItem());
order.addItem(new OrderItem());

em.persist(order);
```

### 🔥 내부 동작

1. persist(order)
2. CascadeType.PERSIST 전파
3. 각 OrderItem에 대해 persist(item) 호출
4. PersistenceContext에 Parent + Child 모두 등록
5. flush 시

   * InsertAction(order)
   * InsertAction(item1)
   * InsertAction(item2)

**모든 insert는 “부모 → 자식” 순으로 정렬되어 실행됨**
(Hibernate가 FK 제약 위반을 피하기 위해 자동 정렬함)

---

## ✔ 2. Parent.remove() → Child.remove() 자동 전파

```java
Order order = em.find(Order.class, id);
em.remove(order);
```

### 🔥 내부 동작

1. remove(order)
2. CascadeType.REMOVE 자동 전파
3. remove(item1), remove(item2)
4. ActionQueue에 DeleteAction(item1), DeleteAction(item2), DeleteAction(order) 순서로 삽입
5. flush
6. DELETE item1
7. DELETE item2
8. DELETE order

즉, **자식이 먼저 삭제되고 부모가 삭제된다.**
이것이 FK 제약을 지키는 올바른 순서이다.

---

## ✔ 3. Parent에서 Child 제거 → 자동 삭제 (orphanRemoval)

```java
order.getItems().remove(item1);
```

### 🔥 내부 동작

1. Parent에서 Child가 제거됨
2. Hibernate가 CollectionEntry의 snapshot과 비교
3. 이전 스냅샷에는 item1 있었고, 현재 없음 → 고아 발생
4. orphanRemoval = true 인 경우
   → DeleteAction(item1) 자동 생성

개발자가 `em.remove(item1)`을 호출할 필요가 없다.

이게 바로 강합성 관계에서 필수인 이유다.

---

# 🟥 5. Strong Composition의 금기 사항

Strong Composition 관계에서 아래 동작은 금지된다:

## ❌ 1. Child를 부모 없이 생성하는 것

Child를 new 하는 순간 ParentRequiredException 같은
도메인 예외를 터뜨리는 것이 설계적으로 맞다.

## ❌ 2. Child를 다른 Parent로 이전시키는 것

예: OrderItem을 Order A에서 빼서 Order B에 붙이기
이건 **합성 규칙을 깨뜨리는 행동**이다.

## ❌ 3. Child를 단독 저장/삭제하는 것

ChildRepository 같은 개념은 나오면 안 된다.

---

# 🟥 6. Strong Composition의 DDD 관점: Aggregate Root

DDD 관점에서는 Strong Composition 관계는 곧 다음 의미가 된다.

> **Parent는 Aggregate Root이고, Child는 Aggregate 내부 엔티티이다.**

### 규칙:

* Aggregate Root만 외부에서 접근/조작 가능
* Aggregate 내부 엔티티는 Root를 통해서만 접근
* Aggregate 내부 엔티티는 Root의 생명주기를 따름
* Aggregate 내부의 불변성(Invariants)은 Root가 책임짐

즉, Strong Composition은 단순 ORM 개념이 아니라
**도메인 모델의 consistency boundary(일관성 경계)**를 의미한다.

---

# 🟥 7. Strong Composition이 성립하는 8가지 조건

아래 조건을 모두 YES라고 답할 수 있어야 Strong Composition이다:

| 질문                                    | Strong Composition 조건 |
| ------------------------------------- | --------------------- |
| 자식은 부모 없이 존재할 수 있는가?                  | ❌ NO                  |
| 자식은 반드시 parent_id(FK)를 가져야 하는가?       | ✔ YES                 |
| parent_id는 NOT NULL인가?                | ✔ YES                 |
| Child는 도메인적으로 Parent의 일부인가?           | ✔ YES                 |
| Parent 삭제 시 Child 삭제는 무조건인가?          | ✔ YES                 |
| 도메인 규칙에서 Child 단독 조작이 금지되는가?          | ✔ YES                 |
| Child는 Parent 외부에서 생성되면 안 되는가?        | ✔ YES                 |
| Cascade ALL + orphanRemoval 조합이 필요한가? | ✔ YES                 |

이 조건이 모두 맞으면
**그 엔티티들은 Strong Composition 관계**입니다.

---

# 🟥 8. 대표적인 Strong Composition 사례

## ✔ Order → OrderItem

전형적인 강합성

## ✔ Delivery → DeliveryAddress

주소는 배송의 일부이며 단독으로 존재할 수 없다

## ✔ Invoice → InvoiceLine

송장 내의 각 라인은 인보이스의 일부

## ✔ Cart → CartItem

장바구니 아이템은 장바구니와 완전히 생명주기를 공유

---

# 🟥 9. JPA에서 Strong Composition을 구현하는 정석 코드

```java
@Entity
public class Order {

    @OneToMany(mappedBy = "order",
               cascade = CascadeType.ALL,
               orphanRemoval = true)
    private List<OrderItem> items = new ArrayList<>();

    public void addItem(OrderItem item) {
        items.add(item);
        item.setOrder(this);
    }

    public void removeItem(OrderItem item) {
        items.remove(item);    // orphanRemoval 자동 삭제
    }
}
```

Child 쪽:

```java
@Entity
public class OrderItem {

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
}
```

여기서 `optional = false` & `nullable = false`는
**자식이 부모 없이 절대 존재할 수 없음을 DB+JPA 양쪽에서 강제**한다.

---

# 🟥 10. Strong Composition vs Weak Composition vs Aggregation 정리표

| 구분          | Aggregation    | Weak Composition   | Strong Composition  |
| ----------- | -------------- | ------------------ | ------------------- |
| 생명주기 공유     | ❌ 없음           | △ 일부 공유            | ✔ 100% 공유           |
| Parent 삭제 시 | 영향 없음          | 직접 제어              | 자동 삭제               |
| Child 독립성   | ✔ 존재           | △ 부분               | ❌ 없음                |
| Cascade     | 거의 ❌           | PERSIST만           | ALL + orphanRemoval |
| FK nullable | 가능             | 가능                 | ❌ NEVER             |
| DDD 의미      | 공유 엔티티         | 보조 엔티티             | Aggregate 내부 엔티티    |
| 예시          | Item–OrderItem | Board–AttachedFile | Order–OrderItem     |

---

# 🎯 Strong Composition 결론

> **Strong Composition은
> 엔티티를 하나의 단일 생명주기 단위로 묶고,
> Parent가 Child의 생성·수정·삭제·저장을 모두 책임지는 구조이다.**
>
> 이는 JPA Cascade ALL + orphanRemoval 조합으로 기술되며,
> Hibernate 내부에서는 CascadeAction + ActionQueue DeleteAction 순서 제어를 통해
> 부모-자식 간 SQL 실행 순서를 보장한다.

