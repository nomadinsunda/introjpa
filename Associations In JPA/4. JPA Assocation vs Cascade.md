# 🚀 JPA 연관관계(Association) vs Cascade — “엔티티 그래프와 영속성 엔진” 관점

대부분의 JPA 교재는 연관관계와 Cascade를 “개념적으로만” 설명합니다.
그러나 실무에서는 **두 개념의 충돌과 상호작용이 어디에서 일어나는지**를 명확히 이해하지 않으면
성능, 무결성, SQL 발행 순서 문제까지 이어져 장애를 만들 수 있습니다.

이번 챕터에서는 다음 네 가지를 동시에 다룹니다:

1. **도메인 모델(객체 구조)**
2. **RDB FK/카디널리티 구조(물리 모델)**
3. **Hibernate 내부 영속성 컨텍스트 구조(엔진 레벨)**
4. **트랜잭션, Flush, Dirty Checking, SQL 생성 원리**

---

# 🟥 1. 연관관계(Association) — **객체 모델 + DB 모델에 존재하는 “구조”**

## 📌 1.1 연관관계는 어디에 존재하는가?

연관관계는 **두 개의 세상 모두에 존재**합니다.

### 🧩 객체 세계 (Object Model)

* Order 객체는 Member 객체를 **참조**한다.
* OrderItem 객체는 Order를 **가지고 있다**.

이 세계에서는 “참조(reference)”만 존재할 뿐
**FK 같은 개념은 존재하지 않습니다.**

### 🧭 데이터베이스 세계 (Relational Model)

* orders.member_id → FK
* order_items.order_id → FK
* 테이블 스키마로 관계가 **강제**된다.

➡️ 연관관계는 **OOP + RDB 설계**가 만나는 지점입니다.

---

## 📌 1.2 연관관계의 본질은 “참조의 방향성 + FK 소유자”

JPA 연관관계는 근본적으로 아래 두 축으로 나뉩니다.

### ✔ (1) “객체 참조 방향성” — 단방향/양방향

* 객체는 양방향 참조가 가능 (Order → Member, Member → Order)
* RDB는 오직 단방향(FK 하나)만 존재함

➡️ 그래서 JPA는 “두 세계의 구조 불일치(impedance mismatch)”를 맞추기 위해
**연관관계 주인(Owner)** 개념을 만들어냅니다.

### ✔ (2) “FK를 관리하는 주체” — Owner(주인)

* `mappedBy`가 없는 쪽이 FK를 관리 → **연관관계 주인**
* 주인이 아닌 쪽은 순수한 “읽기 전용” 관계

예:

```java
@ManyToOne
@JoinColumn(name = "member_id")
private Member member;   // 👈 FK 관리 = 주인
```

---

## 📌 1.3 연관관계는 SQL 생성 시점에 직접 영향을 미친다

연관관계의 주인이 FK를 가지므로
Hibernate는 다음 시점에 **SQL을 생성**합니다.

* flush 시점 (트랜잭션 commit 전)
* dirty checking 후
* 연관관계 변경된 엔티티만 update 수행

즉,

**연관관계는 “어떤 SQL이 발행될지 결정하는 핵심 구조 요인”** 입니다.

Cascade는 이 구조에 전혀 관여하지 않습니다.

---

# 🟩 2. Cascade — **영속성 컨텍스트 내부의 “상태 전파(State Propagation)” 메커니즘**

## 📌 2.1 Cascade는 어디에 존재하는가?

연관관계와 달리 Cascade는 **오직 “영속성 컨텍스트 내부에서만” 존재**합니다.

Cascade는 다음 단계에서 동작합니다:

* `em.persist()`
* `em.remove()`
* `em.merge()`
* `em.detach()`
* `em.refresh()`

즉, Cascade는 “객체가 DB에 어떤 순서로 어떻게 반영될 것인가”에 대한
**행동(behavior)** 을 정의합니다.

---

## 📌 2.2 Cascade는 “상태 머신(State Machine)” 위에서 동작한다

JPA 엔티티는 내부적으로 다음 상태 머신에서 이동합니다.

```
Transient → Persistent → Removed
          ↘
           Detached
```

Cascade는 이 상태 이동을 “그래프 전체로 확장”시키는 역할입니다.

예:

```java
@OneToMany(cascade = CascadeType.PERSIST)
```

→ Parent.persist() 호출 시
→ Child.persist()가 **전파됨**
→ flush 시 Child insert SQL까지 생성됨

### ✨ 핵심

**Cascade는 연관관계를 통해 “탐색된 객체”의 상태를 전파시키는 기능이다.**
연관관계가 없다면 Cascade도 존재할 수 없다.

---

# 🟥 3. 핵심 차이 — “구조 vs 행동”, “모델 vs 엔진”


| 구분         | 연관관계 (Association)      | Cascade                          |
| ---------- | ----------------------- | -------------------------------- |
| 존재 위치      | 객체 모델 + RDB 모델          | 영속성 컨텍스트 내부 엔진                   |
| 목적         | 객체/테이블 구조 정의            | 생명주기 액션 전파                       |
| 관여 요소      | 매핑, FK, 방향성, 주인         | persist/remove/merge propagation |
| SQL 영향     | FK 기반 insert/update     | SQL의 수량과 순서에 영향                  |
| flush 관여   | FK를 가진 주인만 update       | 여러 엔티티를 flush 대상으로 포함            |
| 잘못 탐색 시 문제 | N+1, 잘못된 FK 업데이트        | 대량 삭제 사고, 예상치 못한 insert          |
| UML 대응     | Association/Aggregation | Composition (life cycle sharing) |

---

# 🟦 4. JPA 내부 엔진의 실제 동작 — 연관관계 vs Cascade의 차이를 “엔진 레벨”에서 보기

Hibernate는 내부에서 다음 구조를 가집니다.

```
PersistenceContext
 ├─ EntityEntry (상태, snapshot)
 ├─ CollectionEntry
 ├─ ActionQueue
 │    ├─ InsertAction
 │    ├─ UpdateAction
 │    ├─ DeleteAction
 │    └─ OrphanRemovalAction
 └─ CascadingAction
```

이 중 **Cascade**는 CascadingAction을 통해 수행됩니다.

---

## 🧠 4.1 persist 시나리오 (Cascade vs Association 차이)

### ✔ 연관관계만 있고 Cascade 없을 때

1. `em.persist(order)`
2. 영속성 컨텍스트에 order만 Persistent로 등록
3. flush()
4. InsertAction(order)만 남음
5. `INSERT INTO orders ...`

➡️ 연관관계는 있어도 OrderItem은 비영속 상태 → SQL 안 나감

---

### ✔ CascadeType.PERSIST 있을 때

1. `em.persist(order)`
2. CascadingAction(PERSIST) 실행
3. order.items 컬렉션 순회
4. item1, item2 자동 persist()
5. flush()
6. InsertAction(order)
7. InsertAction(item1)
8. InsertAction(item2)

➡️ SQL이 3개 나감

여기서 핵심:

**Cascade는 영속성 컨텍스트의 ActionQueue에 엔티티를 넣는 역할 을 한다.**
연관관계는 FK를 정의할 뿐, ActionQueue에 아무 것도 넣지 않는다.

---

# 🟥 5. 구조적 관계(연관관계)와 생명주기 관계(Cascade) 의 결합

연관관계와 Cascade를 다음 3가지 레벨로 구분합니다.

---

## 🟨 레벨 1: 순수 Aggregation (공유 관계)

* N:1
* Cascade 없음

예:
OrderItem → Order
Order은 다른 OrderItem에서도 공유됨

**Cascade를 쓰면 안 되는 대표적 관계**
Cascade REMOVE가 걸려 있으면 공유 엔티티까지 삭제하는 참사 발생.

---

## 🟧 레벨 2: Weak Composition (단순 생명주기 결합)

* Parent에서만 생성하고 수정
* Cascade PERSIST 정도만 사용

예:
Board(게시글) → AttachedFile(첨부파일)
삭제는 직접 제어하고 싶을 때

---

## 🟥 레벨 3: Strong Composition (완전 생명주기 공유)

* Cascade ALL + orphanRemoval
* Aggregate Root 전형

예:
Order → OrderItem
Order 삭제 시 OrderItem도 모두 삭제
Order 수정 시 Item 수정도 Root에 의해 관리

---

# 🟩 6. 실제 실무에서 발생한 문제 분석

다음은 실무에서 가장 많이 발생하는 **“관계 vs Cascade 오해로 인한 장애”** 사례입니다.

---

## ❌ 사고 1: ManyToOne에 Cascade ALL

```java
@ManyToOne(cascade = CascadeType.ALL)
```

문제:

* OrderItem을 삭제하는 순간 Item까지 삭제됨
* 다른 Order이 사용 중이던 Item도 함께 삭제
  → 대규모 데이터 손실

⭐ 원인: Aggregation 관계를 Composition처럼 잘못 모델링

---

## ❌ 사고 2: OneToMany 단방향 + Cascade

Hibernate는 단방향 OneToMany + FK 관계를 위해
**매번 update SQL**을 발행합니다.

→ 성능 저하
→ N+1 초래
→ 테이블 설계 불일치

---

## ❌ 사고 3: Cascade REMOVE + orphanRemoval 혼동

```java
@OneToMany(cascade = REMOVE, orphanRemoval = true)
```

* Graph detach 시 불필요하게 대량의 DELETE SQL 발생
* Child를 다른 Parent로 이동시키는 작업이 불가능해짐

---

# 🔥 7. 전문가용 결론: “Association은 모델링의 결과, Cascade는 엔진 동작의 규칙”

### ✔ 연관관계는

* 객체 모델의 연결 구조
* RDB FK 구조
* 연관관계 주인/비주인
* 참조 흐름
* 조회/조인 최적화
* SQL 업데이트 주체
  **→ 구조적 설계(Structure)**

### ✔ Cascade는

* 영속성 컨텍스트 상태 머신 위의
* 생명주기 전파 규칙
* ActionQueue 조작
* flush SQL 생성 순서
  **→ 행동 규칙(Behavior)**

### ✔ 결론

➡️ **연관관계는 “정적 모델링”**
➡️ **Cascade는 “동적 실행 로직”**

이 두 개념은 같은 라인에 적혀 있어도
JPA 내부에서는 다른 세계에 존재한다.

---

# 💎 요약 한 문장

> **연관관계는 “엔티티들이 어떻게 연결되는가”라는 구조적 개념이고,
> Cascade는 “연관된 엔티티가 부모의 생명주기에 따라 어떻게 움직이는가”라는 동적 엔진 규칙이다.**

둘을 혼동하면
잘못된 삭제/저장/병합/조인/성능 문제로 이어지고,
JPA를 제대로 이해한 것이 아니다.

---

필요하시다면 다음 글도 작성해 드릴 수 있습니다.

🔹 **Hibernate ActionQueue 전체 흐름도 + Cascade 동작 순서**
🔹 **Order–OrderItem을 기반으로 연관관계 & Cascade를 완벽 모델링하는 실제 아키텍처 예시**
🔹 **Cascade 전파 + 트랜잭션 + JPQL의 상호작용 시나리오 완전 해설**
🔹 **Aggregate Root 설계 시 Cascade를 언제 쓰고 언제 쓰지 말아야 하는가 (DDD 관점)**

원하시는 방향 알려주시면 바로 이어서 전문가 버전으로 만들어드리겠습니다.
