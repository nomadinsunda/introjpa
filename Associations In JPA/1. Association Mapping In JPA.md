# 📌 JPA Association Mapping: 관계형 DB → 객체 모델 변환의 핵심

## 1. 🔍 왜 Association Mapping이 필수인가?

### ✔ 관계형 DB의 철학

관계형 데이터베이스는 **정규화 규칙(1~6 정규형)** 을 따르며
두 번째 정규화에서는 **무결성 제약조건(FK, PK, UNIQUE)** 을 반드시 포함해야 합니다.

이 정규화 논리에 따라 테이블 간에는 다음의 관계가 형성됩니다:

| 관계 유형        | 설명          |
| ------------ | ----------- |
| One-to-One   | 한 행 ↔ 한 행   |
| One-to-Many  | 한 행 ↔ 여러 행  |
| Many-to-One  | 여러 행 ↔ 한 행  |
| Many-to-Many | 여러 행 ↔ 여러 행 |

### ✔ 객체 모델의 철학

Java 객체는…

* 참조(reference) 기반
* equals/hashCode 기반 비교
* 그래프 탐색 모델
* 상속, 캡슐화, 다형성 구조

을 갖습니다.

**DB의 관계 모델과 객체의 참조 모델은 구조는 비슷하나 동작 원리가 완전히 다르다.**

➡ 그래서 JPA가 DB 구조를 객체 구조로 투영하는 **Association Mapping**을 제공합니다.

---

## 2. 🧱 관계형 모델 → 엔티티 매핑 개요

| 관계          | 예시                 | 객체 방향성  | 조인 모델           |
| ----------- | ------------------ | ------- | --------------- |
| @OneToOne   | Citizen ↔ Passport | 단방향/양방향 | FK 또는 JoinTable |
| @ManyToOne  | Member → Team      | 단방향이 기본 | FK 기반           |
| @OneToMany  | Team → Members     | 양방향 필요  | FK or JoinTable |
| @ManyToMany | User ↔ Authority   | 양방향 권장  | JoinTable 필요    |

➡ 실무에서는 **ManyToMany는 거의 사용하지 않으며**, Join 엔티티를 통한 N:1 + 1:N 구조를 사용.

---

## 3. 🎯 단방향 vs 양방향의 본질

### ✔ 단방향(Unidirectional)

* 객체: 한쪽에서만 참조
* DB: 항상 FK 기반으로 연결
* JPA: 가장 명확·간단 + 성능 예측이 용이

### ✔ 양방향(Bidirectional)

* 객체: 서로 참조 → 양쪽 탐색 가능
* DB: FK는 한 테이블에만 존재 (단 하나!)
* JPA: **연관관계의 주인(owner) 개념이 필요**

➡ 중요한 점:
**양방향은 단방향 2개가 아니다.**
JPA에서 양방향은 “읽기 전용 필드 하나를 추가한 단방향 관계”입니다.

---

## 4. ✔ 주인(Owner)과 비주인(mappedBy)의 근본 개념

**연관관계의 주인 = FK를 관리하는 엔티티**

* 외래 키의 변경(= 관계 변경)이 발생하면 **주인만 DB를 수정할 수 있다**
* 비주인은 읽기 전용(**관계 조회용**)

예:

```java
@ManyToOne
@JoinColumn(name = "team_id")
private Team team; // FK 가진 쪽 → 연관관계 주인
```

반면 Team에서는:

```java
@OneToMany(mappedBy = "team")
private List<Member> members;
```

members는 **단순 조회용(비주인)**.

---

# 🔗 5. 단방향 예제 (제공 내용 유지 + 부족한 설명 강화)

## ✔ 단방향 ManyToOne (가장 기본형)

```java
@Entity
public class OrderItem {

    @Id @GeneratedValue
    private Long id;

    private String productName;
    private int price;

    @ManyToOne
    @JoinColumn(name = "order_id")
    private Order order;
}
```

### 💡 실무 보강 설명

* 단방향 ManyToOne은 항상 **주인**이 됩니니다.
* `@JoinColumn`을 반드시 넣어 FK 컬럼 이름을 명확히 지정해야 한다.
* 기본 FetchType은 LAZY지만, 기본값이 EAGER였던 시절이 있어 반드시 **명시적 LAZY** 권장.

---

# 🔗 6. 양방향 예제 (기존 내용 유지 + 보강)

### ✔ Order — OrderItem 관계

```java
@Entity
public class Order {

    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();

    public void addOrderItem(OrderItem item) {
        orderItems.add(item);
        item.setOrder(this);
    }
}
```

---

### 왜 편의 메서드가 필요한가?

* JPA는 객체/DB를 모두 고려해야 한다
* 객체 world: 양방향 설정 두 곳 모두 해줘야 정상 그래프
* DB world: FK는 한 곳만 존재
* **편의 메서드** 는 객체 그래프를 **항상 일관성 있게 유지**한다

### 실무에서 반드시 지켜야 할 3가지 규칙

1. 연관관계 주인만 FK 변화 가능
2. 양방향이면 **양쪽 모두 관계 설정**해야 함
3. 관리 메서드는 **부모 쪽에 두는 것**이 관례 (`Order.addOrderItem()`)

---

## 7. 🔧 주요 연관 매핑 애노테이션 정리 + 실무 보강

| 애노테이션         | 관계  | 주인      | 특징                                                 |
| ------------- | --- | ------- | -------------------------------------------------- |
| `@OneToOne`   | 1:1 | FK 가진 쪽 | 잘 안씀, 성능 고려 필요                                     |
| `@OneToMany`  | 1:N | 비주인     | 실무에서 단방향 1:N은 거의 사용 X (FK가 반대편에 생김 → UPDATE 2번 발생) |
| `@ManyToOne`  | N:1 | **주인**  | 가장 빈번하게 사용                                         |
| `@ManyToMany` | N:M | 조인 테이블  | 실무 비추천 (중간 엔티티 만들어 해결)                             |

---

## 8. 📘 실전 예제 + 깊은 설명 보강

### ✔ 단방향 1:N (JoinColumn 기반)

```java
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;

    @OneToMany(cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id")
    private List<PhoneNumber> phoneNumbers = new ArrayList<>();
}
```

### ⚠ 실무에서 왜 이 패턴을 지양하는가?

* `User` 엔티티가 `PhoneNumber.user_id` FK를 관리함
* 이는 DB 측면에서는 "User 테이블이 PhoneNumber 테이블을 업데이트"하게 되어 **UPDATE 쿼리가 추가로 발생**
* 실무에서는 **아래 방식(양방향 N:1)** 을 더 선호함

---

### ✔ ManyToMany (보강 설명)

```java
@ManyToMany
@JoinTable(...)
private List<Course> courses;
```

### ⚠ 실무에서는 비추천하는 이유

* 조인 테이블에 추가 속성 (등록일, 상태 등) 넣을 수 없음
* 조인 테이블이 숨겨져 관리 어려움
* 중간 테이블이 비즈니스적으로 중요한 경우가 많음

### ✔ 따라서 실무는 아래 설계를 사용함

```
Student ----< Enrollment >---- Course
```

그리고 Enrollment 엔티티를 따로 만든다.

---

## 9. 🎯 관계별 성능·구조 비교 (보강)

| 관계         | 장점              | 단점                     | 실무 사용도 |
| ---------- | --------------- | ---------------------- | ------ |
| OneToOne   | 구조 직관적          | EAGER 이슈, 잘못된 조인 전략 문제 | 낮음     |
| ManyToOne  | 기본 패턴, 성능 좋음    | 관계 많아지면 조인 많아짐         | 매우 높음  |
| OneToMany  | 단방향 비추천, 양방향 필수 | 주인 문제로 혼란 발생           | 중간     |
| ManyToMany | 구현 쉬움           | 실무에서는 사용 거의 금지         | 매우 낮음  |


