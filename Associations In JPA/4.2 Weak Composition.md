# 🟧 Weak Composition (약한 합성) — 강합성과 단순 집합 관계 사이의 “회색지대”

Weak Composition(약한 합성)은
Aggregation(집합)과 Strong Composition(강합성) 사이의 **중간 단계** 관계입니다.

이 관계는 보통 **도메인 모델링과 실제 운영 요구 사항이 충돌할 때** 등장합니다.

---

## 🟥 1. Weak Composition이 필요한 이유부터 이해하자

Composition(합성)은 원래 다음과 같은 의미입니다.

> **부모(Parent)의 생명주기와 자식(Child)의 생명주기가 하나로 묶인다.
> 부모가 사라지면 자식도 사라지고, 자식은 부모 없이는 존재할 수 없다.**

예시: Order ↔ OrderItem

하지만 실무에서는 **이렇게 명확한 생명주기 결합이 아닌 경우**가 많습니다.

예:

* 게시글(Board)은 첨부파일(AttachedFile)을 가진다.
* **첨부파일은 Board에 속하긴 하지만**,
  삭제 정책에 따라:

  * 게시글 삭제 시 파일 유지하고 싶을 때도 있고
  * 게시글 삭제 시 파일도 함께 삭제하고 싶을 때도 있음
  * 또는 파일은 별도 스토리지(S3)와 연동되어 관리됨

즉,

> “부모와 자식의 생명주기를 완전히 한 몸으로 공유하진 않지만,
> 생성/수정/저장 시에는 Parent가 Child를 관리해야 한다."

이런 미묘한 상황이 **Weak Composition**입니다.

---

## 🟥 2. Weak Composition의 3가지 핵심 특징

### ① Parent가 Child를 **생성/조작/소유**한다

구조적으로 Child는 Parent에 속한다.
Child는 Parent 없이는 의미가 부족하다.

✔ Board가 AttachedFile의 “논리적 소유자”이다.

---

### ② 그러나 Parent의 “삭제”가 Child에게 자동 전파되지 않는다

이게 **Strong Composition과의 가장 큰 차이점**입니다.

* Strong Composition → 삭제 자동 전파 필요
* Weak Composition → 삭제는 정책에 따라 **개별적으로 제어**

따라서 `orphanRemoval = true` 를 쓰지 않는 경우가 많다.

---

## ③ Cascade는 필요한 정도만 적용

대개 **CascadeType.PERSIST**까지만 사용한다.

왜?

* Parent 저장 시 Child 자동 저장은 필요
* 그러나 Parent 삭제 = Child 삭제는 위험할 수 있음

---

## 🟥 3. Strong Composition vs Weak Composition vs Aggregation 비교

| 구분                | Aggregation    | Weak Composition   | Strong Composition  |
| ----------------- | -------------- | ------------------ | ------------------- |
| 생명주기 공유           | ❌ 없음           | △ 부분 공유            | ✔ 완전 공유             |
| Parent 삭제 시 Child | 영향 없음          | 상황에 따라 다름 (직접 제어)  | 반드시 삭제              |
| Child 독립 생존       | ✔ 가능           | △ 제한적              | ❌ 불가능               |
| Cascade           | 거의 없음          | 보통 PERSIST만        | ALL + orphanRemoval |
| 예시                | Item–OrderItem | Board–AttachedFile | Order–OrderItem     |

---

## 🟥 4. Board → AttachedFile 관계를 기준으로 설명

아래처럼 도메인이 있을 때:

```
Board
 └─ AttachedFile 1..N
```

## ✔ AttachedFile은 Board에 속한다

* 파일이 어떤 게시글의 첨부인지 명확히 구분됨
  → 구조적으로는 Composition 성격

## ✔ 하지만 Strong Composition처럼 “무조건 운명을 같이하진 않는다”

운영 정책이 이런 경우가 많다:

> “게시글 삭제 시 첨부파일은 S3에서 지우지 말고,
> 재사용을 위해 남겨두자.”

또는

> “게시글 삭제하면 DB 레코드는 남기되,
> 실제 파일은 바로 삭제하지 말고 배치로 지우자.”

즉, **삭제 동작이 복잡한 비즈니스 정책**을 갖는다.

⭐ 이럴 때 Strong Composition을 적용하면
`cascade = ALL` + `orphanRemoval = true` 때문에
원하지 않는 삭제가 발생한다.

그래서 **Weak Composition**이라는 설계 선택이 필요해진다.

---

# 🟥 5. Weak Composition에서 사용하는 JPA 설정 예시

## 🔧 매핑 예시

```java
@Entity
public class Board {

    @Id @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "board", cascade = CascadeType.PERSIST)
    private List<AttachedFile> files = new ArrayList<>();

    public void addFile(AttachedFile f) {
        files.add(f);
        f.setBoard(this);
    }
}
```

```java
@Entity
public class AttachedFile {

    @Id @GeneratedValue
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "board_id")
    private Board board;
}
```

### 🔍 이 설정의 의미

* Parent(Board) → Child(File)
  ➜ 구조적 Composition

* CascadeType.PERSIST 적용
  ➜ 생성 시에는 Parent가 Child도 같이 persist 운영

* Remove cascade 없음 / orphanRemoval 없음
  ➜ 삭제 시에는 직접 제어가 필요 (Weak Composition)

---

# 🟥 6. Weak Composition에서 “삭제”를 어떻게 제어하는가? (중요!)

Weak Composition의 핵심은 **삭제 정책을 직접 구현한다**는 점이다.

## 📌 1️⃣ 게시글 삭제 시 첨부파일도 같이 삭제

서비스에서 직접 구현:

```java
public void deleteBoard(Long boardId) {
    Board board = boardRepository.findById(boardId)
                                 .orElseThrow();

    // 1. 파일 메타데이터 삭제
    for (AttachedFile file : board.getFiles()) {
        attachedFileRepository.delete(file);   // 직접 삭제
    }

    // 2. Board 삭제
    boardRepository.delete(board);

    // 3. 실제 파일은 S3에서도 삭제할 수도 있고 아닐 수도 있음
}
```

Cascade REMOVE를 써버리면
→ 무조건 child DELETE가 전파되기 때문에
→ 이런 정책적 삭제가 불가능해진다.

---

## 📌 2️⃣ 게시글 삭제해도 첨부파일은 남겨두기

이 요구는 Strong Composition에서는 불가능하다.

Weak Composition에서는 이렇게 한다:

* Board에서 파일 분리 (무관계)
* DB 레코드는 유지
* S3 파일도 유지
* 게시글 삭제

이 구조가 실무에서 정말 많이 사용된다.

---

# 🟥 7. Weak Composition은 JPA 영속성 컨텍스트와도 궁합이 좋음

다음 동작들은 Weak Composition에서 중요한 장점이다.

## ✔ 부모 persist → 자식 persist 자동 전파

CascadeType.PERSIST 덕분에 가능.

## ✔ 부모 delete → 자식 delete 자동 X

orphanRemoval 못 쓰므로 직접 제어 가능.

## ✔ 부모-자식 관계 변경 시

→ 자식 이전 소속을 유지할 수 있음
→ Strong Composition처럼 자동 삭제되지 않음

이건 **도메인 정책이 변경될 때 매우 유연**하다.

---

# 🟥 8. Weak Composition 판별 기준 체크리스트 (전문가용)

아래에 하나라도 YES라면 Weak Composition 후보입니다.

| 질문                               | YES라면…             |
| -------------------------------- | ------------------ |
| 부모 삭제 시 자식을 무조건 삭제해야 하나?         | ❌ Weak Composition |
| 자식이 다른 부모로 이전 가능한가?              | ✔ Weak Composition |
| 자식의 삭제 정책이 복잡한가?                 | ✔ Weak Composition |
| 자식은 기술적으로만 부모에 속하고, 도메인 의미는 약한가? | ✔ Weak Composition |
| 자식 저장은 부모가 책임지지만 삭제는 별도인가?       | ✔ Weak Composition |
| 자식 객체는 반드시 부모와 생명주기를 같이하지 않는가?   | ✔ Weak Composition |

---

# 🟥 9. Aggregation/Weak Composition/Strong Composition 전체 요약

| 구분                | Aggregation    | Weak Composition   | Strong Composition  |
| ----------------- | -------------- | ------------------ | ------------------- |
| 독립 생존             | ✔ 가능           | △ 부분 가능            | ❌ 불가능               |
| Parent 삭제 시 Child | 영향 없음          | 직접 제어              | 자동 삭제               |
| Cascade           | ❌ 거의 없음        | PERSIST            | ALL + orphanRemoval |
| 예시                | Item–OrderItem | Board–AttachedFile | Order–OrderItem     |
| 도메인 결합도           | 매우 낮음          | 중간                 | 매우 강함               |

Weak Composition은
“삭제 정책을 Parent 내부에서 자동화할 수 없을 때” 등장하며,
도메인 모델링 관점에서 매우 중요한 선택입니다.

---

# 🎯 최종 결론

> **Weak Composition은
> ‘구조는 Composition이지만,
> 생명주기 결합은 필요한 만큼만 적용하는 실용적인 합성 관계’**이다.

* Parent는 Child를 생성하고 소유하며
* 저장에서는 Parent가 Child까지 책임지고
* 삭제에서는 Parent가 자식을 자동으로 삭제하지 않고
* 도메인 정책에 따라 유연하게 제어해야 한다

이것이 Weak Composition의 정확한 정의입니다.



어떤 방향으로 더 확장해드릴까요?
