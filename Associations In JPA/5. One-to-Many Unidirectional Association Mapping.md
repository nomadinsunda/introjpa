# 🚀 JPA One-to-Many 단방향 매핑

## 1. 개념 이해: 단순한 “일대다”가 아니다

`OneToMany 단방향`은 생각보다 단순하지 않습니다.
**“객체 모델”과 “DB 모델”을 일치시키기 위한 고육지책”** 에 가깝습니다.

---

## 🧭 2. 왜 복잡한가? — 외래키(FK)의 위치 때문이다

### 🔍 객체 세계

```
Category  →  Product (컬렉션 보유)
```

### 🔍 RDB 세계

FK는 항상 **N쪽(Product)** 에 있어야 한다.

---

### 🧨 문제 발생

JPA 단방향 OneToMany는 이렇게 매핑한다:

```java
@OneToMany
@JoinColumn(name = "CATEGORY_ID")
private List<Product> products;
```

이 말은:

> “외래키(CATEGORY_ID)는 `Product` 테이블에 존재하지만,
> 이 외래키를 **Category 엔티티가 관리한다**”

즉…

| 구분        | 의미           |
| --------- | ------------ |
| 외래키 소유자   | Product 테이블  |
| 외래키 관리 주체 | Category 엔티티 |

⛔ **이 비일관성이 JPA 내부에서 여러 문제를 만든다.**

---

# 3. JPA 내부에서 어떤 SQL이 생성되는가?

실험 코드를 기준으로 다음과 같다.

```java
Category electronics = new Category("Electronics");
electronics.addProduct(p1);
electronics.addProduct(p2);
electronics.addProduct(p3);

em.persist(electronics);
em.persist(p1);
em.persist(p2);
em.persist(p3);
```

### 🔎 실행 SQL 순서

### ① Category INSERT

```sql
insert into category (name) values ('Electronics');
```

### ② Product INSERT (CATEGORY_ID = null)

```sql
insert into product (name, category_id) values ('Laptop', null);
insert into product (name, category_id) values ('Monitor', null);
insert into product (name, category_id) values ('Keyboard', null);
```

### ③ UPDATE 쿼리 3번 (외래키 설정)

```sql
update product set category_id = 1 where id = 10;
update product set category_id = 1 where id = 11;
update product set category_id = 1 where id = 12;
```

---

# 🔥 핵심 문제: **불필요한 UPDATE 폭발**

✔ JPA는 Product INSERT 시 FK를 넣을 수 없다.
왜? 아직 **Category의 PK 값**을 모름.

그래서 INSERT 후에 다시 **UPDATE를 날려 FK를 채운다.**

> 📉 상품 1000개면 UPDATE도 1000번
> 큰 시스템에서는 성능 문제로 매우 치명적

---

# 4. 실무에서 단방향 OneToMany가 거의 금지되는 이유

### ① 성능 문제

* 외래키 업데이트 N번
* batch insert 불가
* 영속성 컨텍스트 동기화 복잡

### ② 관계 주인이 애매하다

FK는 Product가 가지고 있지만
JPA에서는 Category가 소유하는 것으로 간주됨 → **DB 정규화 위반**

### ③ 삭제/수정 시 예측 불가한 SQL 발생

관계 제거 시 UPDATE가 아닌 NULL 업데이트가 일어나는 등 관리가 어려움

### ④ 연관관계가 비즈니스적으로 불명확해짐

실제 외래키는 Product에 있고, DB 기준으로 소유자는 Product인데
객체 기준으로 Category가 소유자가 됨 → 유지보수 지옥

---

# 5. 실무에서 권장되는 대안 (중요)

## 대안 1️⃣: **양방향 OneToMany + ManyToOne**

가장 표준적이며 JPA 철학에 맞는 방식

### Product가 주인

```java
@ManyToOne(fetch = LAZY)
@JoinColumn(name = "CATEGORY_ID")
private Category category;
```

### Category는 mappedBy 사용

```java
@OneToMany(mappedBy = "category")
private List<Product> products = new ArrayList<>();
```

📌 장점

* 외래키 소유자(Product)가 관계를 관리 → SQL 예측 가능
* INSERT 시 FK를 넣을 수 있음 → UPDATE 필요 없음
* 성능, 유지보수 모두 우수

---

## 대안 2️⃣: ManyToOne만 남겨라 (JPA 고수들 추천)

컬렉션을 아예 Category 쪽에 두지 않는다.

```java
// Category에는 product 컬렉션 없음
```

조회 시:

```java
List<Product> products = 
    em.createQuery("select p from Product p where p.category.id = :id")
      .setParameter("id", categoryId)
      .getResultList();
```

✔ 가장 단순
✔ 외래키 방향과 객체의 관계가 동일
✔ 성능 최고
✔ 유지보수 최고

---

## 대안 3️⃣: OneToMany 단방향 + 조인 테이블(JOIN TABLE)

외래키를 Product에 두지 않고 별도 매핑 테이블을 둔다.

```java
@OneToMany
@JoinTable(name = "CATEGORY_PRODUCT",
   joinColumns = @JoinColumn(name = "CATEGORY_ID"),
   inverseJoinColumns = @JoinColumn(name = "PRODUCT_ID"))
private List<Product> products;
```

📌 장점

* UPDATE 폭발 사라짐
* FK 충돌 없음

📌 단점

* 조인 테이블 관리 비용 증가

---

# 6. 예제 개선: 실무 친화적 버전

이제 단방향 OneToMany + JoinColumn 버전을
실무에서 문제 없는 형태로 다시 정리합니다.

---

## ✔ 개선된 Category.java

```java
@Entity
@Table(name = "CATEGORY")
public class Category {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @OneToMany(cascade = CascadeType.PERSIST) 
    @JoinColumn(name = "CATEGORY_ID") // 외래키
    private List<Product> products = new ArrayList<>();

    public void addProduct(Product product) {
        products.add(product);
    }
}
```

### 개선 포인트

* `cascade = PERSIST`를 넣어 Product를 자동 저장
* 그래도 UPDATE 문제는 여전히 존재하지만 "persist 반복 제거"는 가능

---

# 7. UPDATE 폭발 줄이기 위한 팁

✔ **Batch Insert 설정**
하지만 FK 업데이트는 여전히 필요

✔ **insert 순서를 직접 맞추기 위한 JPQL 실행 (비추천)**
JPA의 본래 철학 위반

✔ **Category 먼저 persist → flush → Product persist (triple flush)**
너무 지저분하고 실무에서 거의 사용하지 않음

---

# 💡 결론 — 단방향 OneToMany는 "개념 설명용"이다

정리하면:

| 항목    | 평가                        |
| ----- | ------------------------- |
| 학습    | 👍 개념 이해에는 좋음             |
| 실무 적용 | ❌ 거의 권장 안 함               |
| 이유    | UPDATE 폭발, 관리 난이도, 주인 불일치 |
| 추천 구조 | ManyToOne 또는 양방향          |



