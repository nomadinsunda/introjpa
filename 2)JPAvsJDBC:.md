# 🔍 JPA vs JDBC: 단순 비교를 넘어선 진짜 차이

> “JPA는 단순한 ORM 그 이상이고, JDBC는 여전히 중요한 기술이다. 둘의 차이를 안다는 것은 ‘왜 ORM을 쓰는가’를 이해하는 첫걸음이다.”

---

## 1️⃣ JDBC란?

* **JDBC (Java Database Connectivity)** 는 자바에서 **SQL을 통해 직접 DB를 제어**하는 저수준 API입니다.
* 연결(Connection), 쿼리 작성 및 실행, 결과 처리, 예외 처리 등을 모두 직접 구현해야 합니다.

## 2️⃣ JPA란?

* **JPA (Java Persistence API)** 는 자바 객체와 RDBMS의 **객체-관계 매핑(ORM)** 을 위한 표준 스펙입니다.
* 개발자가 SQL을 몰라도, 객체 중심의 접근만으로 데이터 저장/조회/수정이 가능합니다.

---

## 🔁 JPA vs JDBC 비교 표

| 항목                     | JPA                                  | JDBC                      |
| ---------------------- | ------------------------------------ | ------------------------- |
| **데이터베이스 독립성**         | 쿼리 변경 없이 다양한 DB (MySQL, Oracle 등) 지원 | DB마다 SQL이 다르므로 쿼리도 수정해야 함 |
| **캐시 지원**              | 1차/2차 캐시 기본 제공                       | 직접 캐시 구현 필요               |
| **커넥션 풀**              | 내장 지원 (JPA 구현체에 따라 다름)               | 직접 구현 또는 외부 라이브러리 사용      |
| **SQL 작성 필요**          | 없음 (JPQL, Criteria API 사용)           | SQL 직접 작성 필수              |
| **생산성**                | 높음 (적은 코드, 객체 중심 개발)                 | 낮음 (직접 처리할 것이 많음)         |
| **관계 탐색 지원**           | 객체 간 관계 자동 탐색 및 로딩                   | 외래키 직접 처리 필요              |
| **트랜잭션**               | 내부 트랜잭션 관리 지원                        | JTA 등 직접 구현 필요            |
| **쿼리 튜닝**              | Criteria API 사용 시 자동 최적화             | 수동 튜닝 필수                  |
| **관계 보기**              | Entity 클래스나 XML로 테이블 관계 확인 용이        | 관계 추적 불가능                 |
| **버전 관리 (Versioning)** | 자동 지원 (@Version 등)                   | 미지원                       |
| **데이터 소스 연결**          | JNDI 없이도 연결 가능                       | JNDI API 직접 구현 필요         |

---

## 💡 왜 ORM 프레임워크(JPA)가 필요한가?

JDBC 기반 개발은 다음과 같은 **문제점**을 갖고 있습니다:

* SQL 문법을 DB마다 따로 학습해야 함
* Connection, Statement, ResultSet 처리 반복
* ResultSet을 객체로 수동 매핑 (→ 반복 코드 증가)
* SQL/DB 중심 사고로 객체지향 원칙 무너짐
* 코드량 증가, 생산성 하락

### ✅ ORM 도입 효과

| 효과             | 설명                                 |
| -------------- | ---------------------------------- |
| 🎯 비즈니스 로직에 집중 | SQL 처리 로직 제거로 핵심 로직 집중 가능          |
| 🚀 생산성 향상      | 자동 매핑, 캐싱, 트랜잭션 등으로 빠른 개발          |
| 🔧 유지보수 용이     | 객체 기반 개발로 추적 및 테스트 용이              |
| 🔄 DB 독립성      | DB 교체 시 설정만 변경, 쿼리 수정 최소화          |
| 💾 성능 최적화      | 1차 캐시, 2차 캐시, Lazy Loading 등 기본 제공 |

---

## 🧠 JPA의 추가적인 이점

### 🔸 객체 중심 관계 맵핑

JPA는 1:1, 1\:N, N\:M 관계를 객체 간 관계로 맵핑할 수 있습니다. 아래 예제를 보세요.

```java
class Order {
    @ManyToOne
    private Customer customer;
}
```

* PO(Purchase Order) → Customer 관계를 코드로 탐색 가능
* ORM은 필요한 경우에 Customer 데이터를 자동으로 로딩해줍니다 (지연/즉시 로딩 전략에 따라)

### 🔸 JPQL 사용

```java
SELECT s FROM Student s WHERE s.marks > 90
```

* SQL이 아닌 **객체 기반 쿼리**입니다.
* 테이블명이 아니라 **클래스명**, **필드명** 사용

---

## 🧪 정리: JDBC와 JPA의 용도는 다르다

| 언제 JDBC?                 | 언제 JPA?                |
| ------------------------ | ---------------------- |
| 단순하고 가벼운 DB 처리           | 복잡한 엔티티 간 관계 맵핑        |
| 성능이 절대적으로 중요한 경우 (튜닝 자유) | 유지보수가 중요한 도메인 기반 시스템   |
| 낮은 수준의 DB 제어 필요          | 객체 중심 설계를 최대한 살리고 싶을 때 |
| SQL 기반 쿼리 분석 필수          | 개발 생산성 및 설계 품질 중요할 때   |

---

## 📌 마무리: 개발자가 JPA를 선택해야 하는 이유

JPA는 단순히 **코드를 줄이기 위한 도구**가 아니라, 자바라는 언어가 가진 객체 지향적 사고방식을 **관계형 데이터베이스의 한계 위에서 구현해내기 위한 전략**입니다.

✅ 객체 중심 설계 유지
✅ 코드의 의도와 비즈니스 모델 명확화
✅ DB 독립성 확보
✅ 유지보수성과 확장성 향상

---

## 📎 다음 주제 예고

* 🧱 JPA의 기본 구성 요소(Entity, EntityManager, PersistenceContext)
* 🛠️ JPA 엔티티 설계 방법 및 ID 전략
* 🔄 Fetch 전략 (Lazy vs Eager)
* 💡 JPQL과 Criteria API 마스터하기

