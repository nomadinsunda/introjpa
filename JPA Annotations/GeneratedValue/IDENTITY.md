# ✅ SQL 표준의 IDENTITY 컬럼이란?

`IDENTITY` 컬럼은 \*\*SQL 표준 (SQL:2003\~SQL:2011)\*\*에서 도입된 기능으로,
**자동으로 증가하는 정수 값을 가지는 기본키(primary key) 필드**를 선언하는 데 사용됩니다.

이는 데이터베이스 레벨에서 값을 자동 생성하며, 다음과 같은 특징을 가집니다:

* **DBMS가 자동으로 숫자 값을 생성**
* **명시적으로 시퀀스를 만들지 않아도 됨**
* **SQL 표준 준수 → 이식성 증가**

---

## 📘 1. 기본 문법

```sql
column_name data_type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY
    [ ( START WITH start_num
        INCREMENT BY step
        MINVALUE min
        MAXVALUE max
        CYCLE | NO CYCLE
        CACHE n
    ) ]
```

| 요소                     | 설명                       |
| ---------------------- | ------------------------ |
| `GENERATED`            | 필수 키워드, 자동 생성 컬럼임을 명시    |
| `ALWAYS`               | 사용자가 직접 값을 지정하려 하면 오류 발생 |
| `BY DEFAULT`           | 사용자가 값 지정 가능, 없으면 자동 생성  |
| `AS IDENTITY`          | IDENTITY 열임을 명시          |
| `START WITH`           | 시퀀스 시작 값 (기본: 1)         |
| `INCREMENT BY`         | 증가 간격 (기본: 1)            |
| `MINVALUE`, `MAXVALUE` | 생성 가능한 최소/최대 값           |
| `CYCLE`                | 범위 초과 시 재시작 여부           |
| `CACHE`                | 미리 생성해 캐시에 보관할 개수        |

---

## 📌 2. 예제: 기본 사용

### `GENERATED ALWAYS AS IDENTITY` (가장 엄격한 방식)

```sql
CREATE TABLE users (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  username TEXT NOT NULL
);
```

> ⚠️ 수동 값 삽입 시 오류 발생

```sql
INSERT INTO users (id, username) VALUES (100, 'admin');  -- ❌ 오류 발생
```

### `GENERATED BY DEFAULT AS IDENTITY`

```sql
CREATE TABLE users (
  id INT GENERATED BY DEFAULT AS IDENTITY,
  name TEXT
);
```

> ✅ 사용자가 값을 지정할 수도 있고, 지정하지 않으면 자동으로 할당됩니다.

```sql
-- 자동 증가
INSERT INTO users(name) VALUES ('Alice');

-- 수동 지정 가능
INSERT INTO users(id, name) VALUES (100, 'Bob');
```

---

## 🔍 3. 내부 동작 (PostgreSQL 기준)

PostgreSQL은 이 구문을 내부적으로 **시퀀스 기반**으로 변환합니다:

```sql
-- GENERATED ALWAYS AS IDENTITY
CREATE SEQUENCE users_id_seq START 1 INCREMENT 1;
ALTER TABLE users ALTER COLUMN id SET DEFAULT nextval('users_id_seq');
```

즉, **IDENTITY는 시퀀스의 문법적 추상화**이며,
실제로는 `nextval()` 시퀀스 호출과 동일한 효과를 냅니다.

---

## 🧪 4. IDENTITY vs SEQUENCE vs SERIAL

| 항목          | SERIAL | SEQUENCE | IDENTITY             |
| ----------- | ------ | -------- | -------------------- |
| SQL 표준 호환   | ❌      | ❌        | ✅                    |
| 내부 시퀀스 생성   | 자동     | 수동       | 자동                   |
| 제어 유연성      | 낮음     | 높음       | 중간                   |
| JPA 사용 시 권장 | ❌      | ✅        | 일부 ✅                 |
| 이름 지정 가능    | ❌      | ✅        | ❌ (시퀀스 이름 내부적으로 관리됨) |
| 수동 값 허용     | 가능     | 가능       | `BY DEFAULT`만 가능     |

---

## 💡 5. IDENTITY의 장점과 한계

### ✅ 장점

* ✅ **SQL 표준 호환** → PostgreSQL, SQL Server, DB2 등 다양한 DBMS에서 동일한 방식 사용 가능
* ✅ **명시적 시퀀스 없이 자동 증가 값 제공**
* ✅ **의도 명확**: 수동 값 허용 여부를 옵션으로 제어

### ⚠️ 단점

* ❌ 시퀀스 이름을 직접 지정할 수 없음 (Hibernate 연동 불편)
* ❌ 시퀀스 공유 불가 (여러 테이블에서 같은 시퀀스 사용 못함)
* ❌ 일부 DB에서는 캐시/성능 제어가 제한됨
* ❌ PostgreSQL에서는 `IDENTITY` 사용 시 `RETURNING id` 결과가 `0`이 되는 경우 존재 (JDBC 연동 주의)

---

## 🔄 6. Hibernate에서 IDENTITY 사용

```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;
}
```

* 이 경우 PostgreSQL에서는 \*\*`SERIAL` 또는 `GENERATED AS IDENTITY`\*\*로 자동 생성됩니다.
* Hibernate는 DB Dialect에 따라 `IDENTITY` 전략일 경우 \*\*INSERT 후 `lastval()`\*\*을 사용하여 PK를 얻습니다.

---

## 🔍 7. 시퀀스 파라미터 조회 (PostgreSQL)

```sql
SELECT * FROM information_schema.sequences
WHERE sequence_name = 'users_id_seq';
```

또는 IDENTITY 열 조회:

```sql
SELECT column_name, is_identity, identity_generation
FROM information_schema.columns
WHERE table_name = 'users';
```

---

## ✅ 마무리 요약

| 항목     | 설명                                           |                           |
| ------ | -------------------------------------------- | ------------------------- |
| 정의     | SQL 표준에 따른 자동 증가 기본키 생성 방식                   |                           |
| 핵심 문법  | \`GENERATED \[ALWAYS                         | BY DEFAULT] AS IDENTITY\` |
| 내부 구현  | 시퀀스를 자동 생성하여 사용                              |                           |
| 호환 DB  | PostgreSQL 10+, Oracle 12c+, SQL Server, DB2 |                           |
| JPA 지원 | 일부 Hibernate Dialect에서는 지원                   |                           |
| 권장 상황  | 표준 SQL을 중시하고 이식성을 고려할 때                      |                           |

---

추가로 다음 사항을 고려해 볼 필요가 있습니다:

* PostgreSQL, Oracle, SQL Server에서 `IDENTITY` 전략 비교 실습
* Hibernate + PostgreSQL에서 `IDENTITY` 전략 사용 시 성능과 이슈 분석
* JPA의 `@GeneratedValue(strategy = GenerationType.IDENTITY)`와 SQL 표준 간의 매핑 전략
